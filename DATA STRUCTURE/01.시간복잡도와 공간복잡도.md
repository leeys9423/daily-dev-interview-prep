# 시간복잡도와 공간복잡도에 대해 설명해 주세요.

## 시간복잡도

시간복잡도는 알고리즘의 성능을 평가하는 중요한 척도입니다. 알고리즘이 입력 크기에 따라 얼마나 많은 시간이 필요한지를 수학적으로 표현한 것입니다.

## 공간복잡도

알고리즘이 실행되는 동안 필요한 메모리 공간을 분석하는 척도입니다. 시간복잡도가 알고리즘의 실행 시간을 측정한다면, 공간 복잡도는 메모리 사용량을 측정한다고 할 수 있습니다.

### Big-O, Big-Theta, Big-Omega 에 대해 설명해 주세요.

알고리즘의 성능과 효율성을 수학적으로 표현하는 점근적 표기법입니다.

1. Big-O (O) - 상한 표기
   > Big-O는 알고리즘 실행 시간의 "상한선"을 나타냅니다. 예를 들어 f(n)=O(n²)이라고 하면, f(n)은 "최악의 경우에도 n²보다 빠르게 증가하지 않는다"는 의미입니다. 실제로는 더 적은 걸릴 수 있지만, n²이 상한선이 됩니다.<br><br>
   > 예시 : 버블 정렬의 시간 복잡도는 O(n²)입니다. 입력이 이미 정렬되어 있다면 더 빨리 실행될 수 있지만, 최악의 경우 n²에 비례하는 시간이 걸립니다.
2. Big-Omega (Ω) - 하한 표기
   > Big-Omega는 알고리즘의 "최소 실행 시간"을 나타냅니다. f(n) = Ω(n)이라면, f(n)은 "최선의 경우에도 적어도 n만큼의 시간은 걸린다"는 의미입니다.
   > <br><br>
   > 예시 : 정렬된 배열에서 특정 원소를 찾는 이진 탐색의 경우, 운이 좋아도 Ω(1)의 시간이 걸립니다. 첫 번째 시도에 원하는 값을 찾을 수 있기 때문입니다.
3. Big-Theta (θ) - 상하한 동시 표기
   > Big-Theta는 알고리즘의 실행 시간의 "상한과 하한이 같은 경우"를 나타냅니다. f(n) = θ(n)이라면, f(n)은 "항상 n에 비례하는 시간이 걸린다"는 의미입니다.
   > <br><br>
   > 예시 : 배열의 모든 원소를 순회하며 출력하는 알고리즘은 θ(n)입니다. 입력 크기 n에 정확히 비례하는 시간이 걸리기 때문입니다.

### 다른 것을 사용하지 않고, Big-O를 사용하는 이유가 있을까요?

> 1. 최악의 경우를 나타내기 때문에 알고리즘의 성능을 "보장"할 수 있습니다. 실제 시스템을 설계할 때, 우리는 평균적인 성능보다 최악의 경우를 더 중요하게 고려해야 합니다.
> 2. 실제 상황에서는 입력이 최선의 경우일 가능성이 매우 낮습니다. 대부분의 경우 평균이나 최악의 경우에 가깝습니다.
> 3. Big-Theta는 상한과 하한이 정확히 일치해야 하므로, 많은 알고리즘에 적용하기 어렵습니다.
> 4. 시스템 설계나 알고리즘 선택 시 "안전한"결정을 내릴 수 있게 해줍니다. 만약 O(n²)이라면, 입력 크기가 커질 때 최대 얼마나 많은 자원이 필요한지 예측할 수 있습니다.

### O(1)은 O(N²) 보다 무조건적으로 빠른가요?

> O(1)이 O(N²)보다 무조건적으로 빠르다고 말할 수는 없습니다. 알고리즘의 실제 성능은 입력 크기와 상수 시간(ex - 해시 테이블은 해시 함수 계산, 충돌 처리 등 복잡한 상수 시간 연산이 필요)의 크기에 따라 달라집니다. 이론적으로 충분히 큰 입력에서는 O(1)이 O(N²)보다 빠르지만, 작은 입력에서는 반드시 그렇지 않습니다.
