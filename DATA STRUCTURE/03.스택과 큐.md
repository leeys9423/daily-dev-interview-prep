# 스택과 큐에 대해서 설명해 주세요.

## 스택

스택은 <b>후입선출</b>(LIFO: Last In First Out) 원칙을 따르는 자료구조 입니다.

> 프로그램의 실행 순서와 스택의 관계<br>
> 프로그램이 실행될 때 메모리는 크게 스택 영역과 힙 영역으로 나뉩니다. 여기서 스택 영역은 메서드 호출과 관련된 정보를 관리합니다.<br>
> 메인 메서드안에 여러 함수들이 호출되는 상황을 가정하고, 메인 메서드가 실행되는 과정을 설명해보겠습니다.<br>
> 먼저 메인 메서드가 호출되면 스택에 메인 메서드의 스택 프레임이 쌓입니다. 코드의 위에서 부터 아래로 실행되면서, 함수1을 만났다고 했을 때, 함수1이 스택 프레임에 쌓이고, 함수1이 처리가 되면 스택 영역에 사라지고 다시 아래로 실행됩니다.<br>
> 코드가 순차적으로 실행되기 때문에 FIFO처럼 느껴지지만, 실제 메모리 관리 측면에서는 스택에 쌓였다가 제거되는 LIFO 구조로 동작합니다.

## 큐

큐는 <b>선입선출</b>(FIFO: First In First Out) 원칙을 따르는 자료구조 입니다.

### 스택 2개로 큐를, 큐 2개로 스택을 만드는 방법과, 그 시간복잡도에 대해 설명해 주세요.

1. <b>스택 2개를 활용하여 큐를 구현하는 방법</b><br>
   먼저 입력용 스택(스택 1)과 출력용 스택(스택 2)을 준비합니다. 새로운 요소가 들어올 때마다 입력용 스택에 순서대로 쌓습니다. 요소를 꺼내야 할 때는 입력용 스택의 모든 요소를 출력용 스택으로 옮기는데, 이 과정에서 요소들의 순서가 자연스럽게 뒤집히게 됩니다. 이렇게 하면 출력용 스택에서 요소를 꺼낼 때 가장 먼저 들어온 요소가 가장 먼저 나오는 큐의 FIFO(First-In-First-Out) 특성을 구현할 수 있습니다.
   시간복잡도 측면에서는, 각각의 요소가 입력용 스택에서 출력용 스택으로 이동하는 과정에서 최대 두 번의 이동(pop와 push)이 발생하므로 O(2n)이 되고(이동에 대한 총 연산은 O(4n)), 빅오 표기법의 특성상 상수는 제외되어 최종적으로 O(n)의 시간복잡도를 가집니다.
2. <b>큐 2개를 활용하여 스택 구현하는 방법</b><br>
   큐 2개를 활용하여 스택을 구현하는 방법은 다음과 같습니다. 먼저 주 저장소 역할을 하는 큐(큐 1)와 보조 저장소 역할을 하는 큐(큐 2)를 준비합니다. 새로운 요소가 들어올 때는 단순히 주 저장소 큐에 enqueue 연산을 수행하여 저장합니다.<br>
   요소를 꺼내야 할 때는 주 저장소 큐에서 마지막 요소를 제외한 모든 요소를 보조 저장소 큐로 옮깁니다. 그 다음 주 저장소 큐에 남은 마지막 요소를 dequeue하여 반환하고, 보조 저장소에 있는 모든 요소를 주 저장소로 옮깁니다. 이러한 과정을 통해 가장 나중에 들어온 요소가 가장 먼저 나가는 스택의 LIFO(Last-In-First-Out)특성을 구현할 수 있습니다.<br>
   시간복잡도 측면에서는, 새로운 요소를 추가하는 push 연산은 단순한 enqueue 연산만 수행하므로 O(1)의 시간복잡도를 가집니다. 반면 요소를 꺼내는 pop 연산은 n-1개의 요소를 보조 저장소로 옮기고(n-1), 마지막 요소를 꺼내고 O(1), 다시 n-1개의 요소를 주 저장소로 옮기는 과정이 필요하므로, 총 2n-1번의 연산이 필요해 O(n)의 시간복잡도를 가집니다.

### 시간복잡도를 유지하면서, 배열로 스택과 큐를 구현할 수 있을까요?

1. <b>스택을 구현하는 방법</b><br>
   배열의 한쪽 끝을 스택의 top으로 지정하고, top을 가리키는 인덱스 변수를 유지합니다. 새로운 요소를 추가할 때는 top 인덱스를 증가시키고, 해당 위치에 요소를 저장하며, 요소를 제거할 때는 top 위치의 요소를 반환하고 top 인덱스를 감소시킵니다.<br>
   이 방식으로 구현하면 push와 pop연산 모두 O(1)의 시간복잡도를 유지할 수 있습니다.
2. <b>배열로 큐를 구현하는 방법</b><br>
   큐를 배열로 구현할 때는 두 개의 인덱스가 필요합니다. front는 큐의 첫 번째 요소를 가리키고, rear는 새로운 요소가 들어갈 위치를 가리킵니다. 새로운 요소를 추가할 때 rear위치에 요소를 저장하고 rear를 증가시키며, 요소를 제거할 때는 front의 위치의 요소를 반환하고 front를 증가시킵니다.<br>
   여기서 주의할 점은 배열의 끝에 도달했을 때입니다. 이를 해결하기 위해 원형 큐개념을 도입합니다. 인덱스가 배열의 끝에 도달하면 다시 배열의 처음으로 돌아가도록 구현합니다.

제한사항: 이러한 구현의 한 가지 제한사항은 배열의 크기가 고정되어 있다는 점입니다. 이를 해결하기 위해서는 동적 배열을 도입해야 합니다. 배열이 가득 찼을 때, 더 큰 크기의 새로운 배열을 할당하고 기존 요소들을 복사하는 방식입니다. 이 경우 평균적인 시간복잡도는 여전히 O(1)이지만, 배열을 재할당하는 순간에는 O(n)의 시간이 필요합니다.

### Prefix, Infix, Postfix 에 대해 설명하고, 이를 스택을 활용해서 계산/하는 방법에 대해 설명해 주세요.

1. Prefix(전위 표기법)<br>
   연산자가 피연산자들 앞에 위치하는 표기법입니다. "2 + 3"을 prefix로 표현하면 "+ 2 3"이 됩니다. 괄호 없이도 연산 순서가 명확하다는 장점이 있습니다.
2. Infix(중위 표기법)<br>
   우리가 일상적으로 사용하는 수식 표기 방법입니다. 연산자가 두 피연산자 사이에 위치합니다. 예를 들어 "2 + 3"과 같은 형태입니다.
3. Postfix(후위 표기법)<br>
   연산자가 피연산자들 뒤에 위치하는 표기법입니다. "2 + 3"을 postfix로 표현하면 "2 3 +"가 됩니다. 컴퓨터가 계산하기에 가장 적합한 형태입니다.

컴퓨터가 수식을 계산할 때는 일반적으로 두 단계를 거칩니다.<br>
첫 번째 단계는 파싱(Parsing) 단계입니다. 입력한 수식을 Postfix로 변환하는 과정입니다.<br>

> Infix(중위 표기법)를 Postfix(후위 표기법)으로 변환하는 방법
>
> 1. 스택과 결과를 저장할 문자열을 준비합니다.<br><br>
> 2. 수식을 왼쪽에서 오른쪽으로 읽으면서,
>
> - 숫자는 바로 결과 문자열에 추가
> - 여는 괄호("(")는 스택에 push
> - 닫는 괄호(")")를 만나면 여는 괄호가 나올 때까지 스택에서 pop하여 결과에 추가
> - 연산자는 스택의 top에 있는 연산자와 우선순의 비교 후 처리

두 번째 단계는 계산(Evaluation) 단계입니다. Postfix로 변환된 수식을 스택을 사용하여 실제로 계산하는 과정입니다.<br>

> Postfix의 계산 방법<br>
> 왼쪽에서 오른쪽으로 읽으면서:
>
> - 숫자는 스택에 push
> - 연산자를 만나면 스택에서 두 개의 숫자를 pop하여 계산 후 결과를 다시 push

### Deque는 어떻게 구현할 수 있을까요?

1. 배열을 사용한 구현 방법
   원형 배열 구조를 활용합니다. front와 rear 두 개의 포인터를 사용하여 배열의 양 끝을 관리하며, 나머지 연산을 통해 배열을 원형으로 사용함으로써 메모리를 효율적으로 활용할 수 있습니다.
2. 이중 연결 리스트를 사용한 구현
   각 노드가 이전 노드와 다음 노드를 모두 가리키는 구조를 사용하여, 양방향으로 이동이 자유로운 특성을 활용합니다.
