# 해시 자료구조에 대해 설명해 주세요.

## 해시

키(key)와 값(value)을 매핑하여 데이터를 저장하고 검색하는 효율적인 자료구조 입니다.<br>
해시 자료구조의 핵심 요소들을 살펴보면:<br>

1. 해시 함수 - 해시 함수는 입력된 키를 특정 숫자로 변환합니다. 이 숫자는 배열의 인덱스로 사용됩니다.
2. 충돌 처리 - 서로 다른 키가 같은 해시 값을 가질 수 있는데, 이를 충돌이라고 합니다. 해결 방법은 다음과 같습니다.
   1. 체이닝: 같은 위치에 여러 데이터를 연결 리스트로 저장
   2. 개방 주소법: 충돌이 발생하면 다른 빈 공간을 찾아 저장

장점: <br>

1. 검색, 삽입, 삭제 연산이 평균적으로 O(1) 시간 복잡도를 가집니다.
2. 키를 통한 직접 접근이 가능하여 데이터를 빠르게 처리할 수 있습니다.

주의점: <br>

1. 해시 함수의 품질이 성능에 큰 영향을 미칩니다. <br>
   - 해시 함수가 특정 위치에만 데이터를 몰아넣는다면, 그 위치는 매우 혼잡해지고 다른 위치들은 텅 비게 됩니다.
2. 최악의 경우 시간 복잡도가 O(n)이 될 수 있습니다. <br>
   - 모든 데이터가 동일한 해시값을 가질 때 발생합니다.
3. 공간 효율성이 상대적으로 떨어질 수 있습니다. <br>
   - 해시 테이블은 충돌을 줄이기 위해 실제 저장할 데이터보다 더 큰 공간을 미리 할당해야 합니다.

### 값이 주어졌을 때, 어떻게 하면 충돌이 최대한 적은 해시 함수를 설계할 수 있을까요?

1. 결정성을 보장해야 합니다. 동일한 입력에 대해 항상 동일한 해시값을 반환해야 합니다.
   - 결정성이 보장되지 않는 대표적인 예시 - `System.identityHashCode()` 이 메서드는 객체의 메모리 주소를 기반으로 해시값을 생성하므로, 같은 내용을 가진 객체라도 다른 해시값을 가질 수 있습니다.
2. 균일 분포를 만들어야 합니다. 이를 위해 널리 사용되는 기법이 곱셈 해시 방법입니다.
   - 황금비 곱셈 - 황금비는 무리수이므로, 곰셉 결과가 반복되는 패턴을 만들지 않고, 가장 비합리적인 수 중 하나로, 결과값들이 매우 고르게 분포되게 만듭니다.
3. 눈사태 효과를 고려해야 합니다.(예측할 수 없도록) 입력값이 조금만 달라져도 해시값이 크게 변해야 합니다. (비트 시프트 연산...)
4. 입력 데이터의 특성을 고려해야 합니다.
5. 실제 환경에서는 데이터의 특성과 사용 패턴에 따라 해시 함수를 조정해야 합니다.
   1. 데이터가 주로 연속된 정수라면 곱셈 해시
   2. 문자열이 많다면 각 문자의 위치를 고려한 해시
   3. 보안이 중요하다면 암호학적 해시 함수

### 해시값이 충돌했을 때, 어떤 방식으로 처리할 수 있을까요?

1. 체이닝: 같은 위치에 여러 데이터를 연결 리스트로 저장
2. 개방 주소법: 충돌이 발생하면 다른 빈 공간을 찾아 저장

### 본인이 사용하는 언어에서는, 어떤 방식으로 해시 충돌을 처리하나요?

Java 8 이전에는 단순한 연결 리스트를 사용했습니다.(체이닝) Java 8 이후에는 하이브리드 방식을 도입했습니다.<br>
하이브리드 방식의 핵심은 데이터의 개수에 따라 두 가지 다른 자료구조를 사용한다는 점입니다. 하나의 버킷에 저장된 데이터가 8개 이하일 때는 연결 리스트를 사용하고, 8개를 초과하면 레드-블랙 트리로 전환됩니다. 데이터가 적을 때는 단순한 연결 리스트가 메모리 사용량도 적고 구현도 단순해서 효율적입니다. 하지만 데이터가 많아지면 연결 리스트의 검색 시간이 O(n)으로 급격히 늘어나기 때문에, 이때는 O(log n)의 시간 복잡도를 가진 레드-블랙 트리가 더 효율적입니다.

### Double Hashing 의 장점과 단점에 대해서 설명하고, 단점을 어떻게 해결할 수 있을지 설명해 주세요.

Double Hashing은 개방 주소법 방식의 충돌 해결 기법 중 하나입니다. 첫 번째 해시 함수로 계산한 위치에서 충돌이 발생하면, 두 번째 해시 함수를 사용하여 다음 위치를 계산합니다. <br>
장점: <br>

1. Linear Probing (선형 탐사)나 Quadratic Probing (제곱 탐사)에 비해 클러스터링(군집화) 현상이 적게 발생합니다.
2. 두 번째 해시 함수를 통해 더 균일한 분포를 얻을 수 있습니다.
3. 충돌이 발생했을 때 다음 위치를 찾는 패턴이 예측하기 어려워, 보안적으로도 이점이 있습니다.

단점: <br>

1. 두 개의 해시 함수를 계산해야 하므로 계산 비용이 증가합니다.
2. 두 번째 해시 함수의 값이 0이 되면 무한 루프에 빠질 수 있습니다.
3. 캐시 효율성이 떨어질 수 있습니다.(메모리 지역성 문제)
4. 테이블이 거의 가득 찼을 때 성능이 급격히 저하될 수 있습니다.

개선사항: <br>

1. 계산 비용 문제
   1. 해시 함수를 최대한 단순하게 유지
   2. 비트 연산을 활용하여 효율성 향상
2. 무한 루프 방지
   1. 두 번째 해시 함수가 0을 반환하지 않도록 보정
   2. 테이블 크기를 소수로 설정하거나 2의 거듭제곱으로 설정
3. 캐시 효율성
   1. 삭제된 항목을 표시하는 플래그 사용
   2. 주기적인 리사이징으로 데이터 재배치
4. 성능 저하 방지
   1. 로드 팩터를 모니터링하여 동적으로 크기 조정
   2. 효율적인 리사이징 정책 적용

### Load Factor에 대해 설명해 주세요. 본인이 사용하는 언어에서의 해시 자료구조는 Load Factor에 관련한 정책이 어떻게 구성되어 있나요?

로드 팩터는 해시 테이블의 '채워진 정도'를 나타내는 지표입니다. 수식으로는 저장된 데이터의 개수 / 해시 테이블의 크기 입니다.
기본값은 0.75로, 테이블의 75%가 차면 자동으로 테이블의 크기를 조정하여 해시 충돌의 가능성을 줄입니다.

### 다른 자료구조와 비교하여, 해시 테이블은 멀티스레드 환경에서 심각한 수준의 Race Condition 문제에 빠질 위험이 있습니다. 성능 감소를 최소화 한 채로 해당 문제를 해결할 수 있는 방법을 설계해 보세요.

해시 테이블은 resizing 작업이 발생할 때 내부 버킷 배열 전체를 재구성하는데, 이 때 여러 스레드가 동시에 접근하면 심각한 데이터 일관성 문제가 발생할 수 있습니다. 또한 체이닝 방식에서는 연결 리스트나 트리의 구조를 수정 할 때도 Race Condition이 발생할 수 있습니다.

해결방법: <br>

1. 분할 잠금방식을 사용합니다. 하나의 큰 해시 테이블을 여러 개의 세그먼트로 나누고, 각 세그먼트가 독립적인 락을 가지도록 합니다. 이를 통해 서로 다른 세그먼트에 대한 동시 접근이 가능해져 전체적인 성능이 향상됩니다.
2. CAS(Compare-And-Swap) 연산을 활용하여 세그먼트 내부의 세밀한 동시성을 제어합니다. 이는 락보다 더 가벼운 동기화 방식을 제공합니다.
3. 리사이징 작업을 세그먼트 단위로 수행합니다. 전체 테이블이 아닌 특정 세그먼트만 리사이징하므로, 다른 세그먼트에 대한 접근은 영향을 받지 않습니다.

실제로 이는 ConcurrentHashMap이 채택한 방식과 유사한 접근법입니다.
