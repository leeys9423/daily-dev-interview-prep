# 트리와 이진트리, 이진탐색트리에 대해 설명해 주세요.

## 트리

트리는 계층적인 구조를 가지고 있습니다. 맨 위에는 루트(root) 노드가 있고, 그 아래로 여러 개의 자식 노드들이 연결됩니다.
특징: <br>

1. 계층 구조: 모든 노드는 단 하나의 부모 노드를 가집니다.
2. 순환이 없음: 노드들 사이에 순환하는 경로가 존재하지 않습니다.
3. 연결성: 모든 노드는 서로 연결되어 있으며, 루트 노드로부터 어떤 노드든 도달할 수 있습니다.

## 이진트리

각 노드가 최대 두 개의 자식을 가질 수 있는 트리입니다.

## 이진탐색트리

왼쪽 자식은 항상 부모보다 작고, 오른쪽 자식은 항상 부모보다 큰 값을 가지는 특별한 이진 트리입니다.

### 그래프와 트리의 차이가 무엇인가요?

1. 순환(Cycle)
   - 그래프: 순환이 허용 됩니다.
   - 트리: 순환이 절대 허용되지 않습니다.
2. 부모-자식 관계
   - 그래프: 노드들 사이에 부모-자식 같은 계층 관계가 없습니다. 모든 노드가 동등한 위치에 있습니다.
   - 트리: 명확한 계층 구조가 있습니다. 각 노드(루트 제외)는 정확히 하나의 부모를 가집니다.
3. 루트 노드
   - 그래프: 특별한 시작점이 없습니다.
   - 트리: 반드시 하나의 루트 노드가 있어야 합니다.
4. 연결 방향
   - 그래프: 방향이 있을 수도, 없을 수도 있습니다.
   - 트리: 항상 부모에서 자식으로 향하는 단방향 구조입니다.

### 이진탐색트리에서 중위 탐색을 하게 되면, 그 결과는 어떤 의미를 가지나요?

노드들을 오름차순으로 방문하게 됩니다. 이진탐색트리의 기본 속성은 왼쪽 서브트리에 있는 값들은 해당 노드의 값보다 작고, 모든 노드의 오른쪽 서브트리에 있는 값들은 해당 노드의 값보다 큽니다.<br>
그리고 중위 탐색은 왼쪽 서브트리를 방문, 현재 노드 방문, 오른쪽 서브트리를 방문 순서대로 진행됩니다. 두 개의 특징이 결합이 되면 정렬된 순서를 얻을 수 있습니다.<br>
이를 응용하여 범위 검색을 할 수 있고, 데이터베이스 시스템, 파일 시스템의 디렉토리 구조, 다양한 검색 알고리즘에서 이 특성이 활용됩니다.

### 이진탐색트리의 주요 연산에 대한 시간복잡도를 설명하고, 왜 그런 시간복잡도가 도출되는지 설명해 주세요.

1. 검색: 균형잡힌 트리 O(log n), 불균형 트리 O(n)
   - 이유: 매 비교마다 탐색 범위가 절반으로 줄어들기 때문
2. 삽입: 균형잡힌 트리 O(log n), 불균형 트리 O(n)
   - 새 노드를 삽입할 위치를 찾는 과정은 O(log n) 삽입 과정은 O(1)
3. 삭제: 균형잡힌 트리 O(log n), 불균형 트리 O(n)
   - 노드 찾는 과정 O(log n) 리프 노드 삭제시 O(1), 자식이 하나인 노드 삭제시 O(1), 자식이 둘인 노드 삭제시 O(log n)

### 이진탐색트리의 한계점에 대해 설명해주세요.

가장 근본적인 한계는 트리의 균형과 관련이 있습니다. 데이터가 삽입되는 순서에 따라 트리의 성능이 크게 달라질 수 있습니다. 한쪽으로 치우치게 되면 시간복잡도가 O(n)에 수렴하게 됩니다.<br>
두 번째 한계점은 메모리 사용의 비효율성입니다. 각 노드가 데이터뿐만 아니라 두 개의 포인터를 추가로 저장해야 합니다. <br>
세 번째 한계점은 캐시 지역성이 좋지 않다는 것입니다. 이진탐색트리에서는 노드들이 메모리상에 연속적으로 배치되지 않아 캐시 미스가 자주 발생할 수 있습니다. <br>
넷째 트리의 재구성이 필요한 경우, 이는 추가적인 연산 비용을 발생시킵니다.

### 이진탐색트리의 값 삽입, 삭제 방법에 대해 설명하고, 어떤식으로 값을 삽입하면 편향이 발생할까요?

값 삽입 과정은 트리가 비어있으면 새 노드를 생성하고, 현재 노드의 값과 비교하여 왼쪽 또는 오른쪽으로 이동하여 자리를 찾아 삽입합니다. <br>
삭제는 세 가지 경우를 고려해야 합니다. <br>
먼저 삭제할 노드를 찾습니다. 그 후 그 노드가 리프 노드인지, 자식 노드가 몇개 인지를 알아야합니다.
리프 노드일 경우 바로 삭제가 가능합니다. 자식이 하나인 경우는 노드를 삭제하고 그 위치에 자식 노드를 배치시킵니다. 마지막 자식이 둘인 경우 오른쪽 서브트리에서 가장 작은 값을 찾아 현재 노드를 대체합니다. <br>

편향이 발생하는 경우 <br>

1. 정렬된 데이터를 삽입

### 이진탐색트리와 동일한 로직을 사용하면, 삼진탐색트리도 정의할 수 있을까요? 안 된다면, 그 이유에 대해 설명해 주세요.

삼진탐색트리를 이진탐색트리와 동일한 로직으로 정의하는 것은 이론적으로 가능하지만, 실용적이지 않은 여러 가지 근본적인 문제점을 가지고 있습니다.<br>
핵심적인 문제는 이진탐색트리의 기본 원리인 "하나의 비교로 검색 공간을 나누는" 특성을 유지하기 어렵다는 점입니다. 이진탐색트리에서는 각 노드에서 하나의 비교만으로 왼쪽 또는 오른쪽으로 이동할지를 결정할 수 있습니다. 하지만 삼진탐색트리에서는 세 방향으로 분기하기 위해 각 노드에서 최소 두 번의 비교가 필요합니다. <br>
이러한 그조는 이진탐색트리의 가장 큰 장점인 "한 번의 비교로 검색 공간을 절반으로 줄이는" 효율성을 잃게 됩니다. 또한 노드의 삽입과 삭제 시에도 두 개의 기준값을 어떻게 조정할지, 노드의 균형을 어덯게 유지할지 등의 추가적인 복잡성이 발생합니다.
