# 쿠키와 세션에 대해서 설명해주세요.

쿠키와 세션은 HTTP의 비연결성과 무상태성의 한계를 보완하기 위한 중요한 기술입니다.

먼저 쿠키에 대해서 설명드리면, 쿠키는 클라이언트 측에 저장되는 작은 데이터 조각입니다.<br>
예를 들어 사용자가 '장바구니에 담기'를 클릭했을 때, 그 상품 정보를 쿠키에 저장해두면 페이지를 이동하더라도 장바구니 정보가 유지됩니다. 쿠키는 이름, 값, 만료시간, 도메인 등의 속성을 가지며, 클라이언트에서 서버로 요청할 때마다 함께 전송됩니다.<br>
<br>
세션은 서버 측에서 관리되는 데이터입니다. 사용자가 로그인했을 때, 서버는 세션 ID를 생성하고 이를 쿠키를 통해 클라이언트에게 전달합니다. 이후 클라이언트는 이 세션 ID를 가지고 서버와 통신하며, 서버는 이 ID를 통해 사용자를 식별합니다.<br>
<br>
두 기술의 주요 차이점은 보안성에 있습니다. 쿠키는 클라이언트에 저장되어 사용자가 수정할 수 있기 때문에 중요한 정보는 세션에 저장하는 것이 안전합니다.

## 꼬리질문 1. 세션 방식의 로그인 과정에 대해 설명해주세요.

세션 기반 로그인은 크게 인증과 인가 두 단계로 나눌 수 있습니다.
먼저 인증 과정을 설명해드리면, <br>
사용자가 로그인 페이지에서 아이디와 비밀번호를 입력하고 제출하면, 이 정보는 서버로 전송됩니다. 서버는 전달받은 아이디로 데이터베이스를 조회하고, 비교합니다.<br>
인증이 성공되면 서버는 세션 생성 단계로 넘어갑니다.<br>
서버는 유니크한 세션 ID를 생성합니다. 그리고 이 세션 ID를 클라이언트에게 쿠키로 전달합니다.<br>
<br>
이후 인가 과정은 다음과 같이 진행됩니다.<br>
클라이언트가 서버에 요청을 보낼 때마다 쿠키에 저장된 세션 ID가 자동으로 함께 전송됩니다. 서버는 이 세션 ID로 세션 스토어를 조회하여 사용자를 식별하고, 요청한 리소스에 대한 접근 권한이 있는지 확인합니다.<br>
권한이 있다면 요청을 처리하고, 없다면 401이나 403 같은 적절한 HTTP 상태 코드로 응답합니다.

## 꼬리질문 2. HTTP의 특성인 Stateless에 대해 설명해 주세요.

HTTP의 Stateless는 각각의 HTTP 요청이 이전 요청과 완전히 독립적으로 처리되는 특성을 의미합니다. 즉, 서버는 이전 요청에 대한 상태나 맥락을 전혀 기억하지 않고, 모든 요청을 새로운 요청으로 처리합니다.<br>
이러한 Stateless 특성은 서버의 확장성과 성능 면에서 큰 장점을 가집니다. 각 요청이 독립적이기 때문에 서버를 확장하기 쉽고, 여러 서버에 요청을 분산하기가 용이합니다. 또한 서버가 클라이언트의 상태 정보를 유지할 필요가 없어 서버 리소스를 효율적으로 사용할 수 있습니다.<br>
하지만 이러한 Stateless 특성으로 인해 로그인 상태 유지와 같이 상태 관리가 필요한 기능을 구현하는데 제약이 있습니다. 이를 해결하기 위해 쿠키, 세션, JWT와 같은 기술을 사용하여 클라이언트나 서버 측에서 상태를 관리하는 방식으로 이 한계를 보완하고 있습니다.

### 꼬리질문 2-1. Stateless의 의미를 살펴보면, 세션은 적절하지 않은 인증 방법 아닌가요?

HTTP의 Stateless는 '서버가 클라이언트의 이전 요청을 기억하지 않는다'라는 의미입니다. 세션을 사용하더라도, 이 원칙은 여전히 지켜지고 있습니다.<br>
왜냐하면, 클라이언트가 매 요청마다 세션 ID를 함께 전송하기 때문에, 서버는 이전 요청을 기억할 필요가 없습니다. 서버는 현재 요청에 포함된 세션 ID만을 사용해 사용자를 식별합니다.<br>
즉, 세션은 Stateless한 HTTP의 한계를 보완하기 위한 애플리케이션 레벨의 해결책이지, HTTP의 Stateless 속성을 위배하는 것이 아닙니다.

### 꼬리질문 2-2. 규모가 커져 서버가 여러 개가 된다면, 세션을 어떻게 관리할 수 있을까요?

서버가 여러 대로 늘어났을 때의 세션 관리는 크게 4가지 방식으로 해결할 수 있습니다.<br>
첫째, 스티키 세션 방식 입니다. 로드 밸런서가 특정 사용자의 요청을 항상 동일한 서버로 보내도록하는 것입니다.<br>
사용자별로 처음 요청이 처리된 서버를 기억해두었다가, 이후 요청들을 모두 같은 서버로 전달합니다. 구현이 간단하다는 장점이 있지만, 특정 서버에 부하가 집중되거나 서버가 다운되면 해당 서버에 저장된 모든 세션이 손실되는 단점이 있습니다.<br><br>
둘째, 세션 클러스터링 방식 입니다. 여러 서버가 세션 정보를 공유하여 동기화하는 방식입니다. 한 서버에 세션이 생성되거나 수정되면 다른 모든 서버에도 그 내용이 복제됩니다. 모든 세션 정보가 모든 서버에 동일하게 유지되므로 안정적이지만, 비효율적인 단점이 있습니다.<br><br>
셋째, 세션 스토리지 분리 방식입니다. Redis나 Memcached 같은 별도의 세션 스토리지를 두어 모든 서버가 이를 공유하는 방식입니다. 모든 서버가 동일한 세션 스토리지를 바라보기 때문에 세션 정보의 일관성이 보장되고, 서버간 동기화가 필요없어 효율적입니다.<br><br>
넷째, JWT와 같은 토큰 기반 인증 방식으로 전환하는 것입니다. 서버에 상태를 저장하지 않고, 필요한 정보를 토큰에 담아 클라이언트가 가지고 있게 하는 방식입니다.
